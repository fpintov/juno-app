{"ast":null,"code":"import _asyncToGenerator from \"C:/Repository/Jupiter/juno-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (reference, floating, config) {\n    const {\n      placement = 'bottom',\n      strategy = 'absolute',\n      middleware = [],\n      platform\n    } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = yield platform.isRTL == null ? void 0 : platform.isRTL(floating);\n    let rects = yield platform.getElementRects({\n      reference,\n      floating,\n      strategy\n    });\n    let {\n      x,\n      y\n    } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for (let i = 0; i < validMiddleware.length; i++) {\n      const {\n        name,\n        fn\n      } = validMiddleware[i];\n      const {\n        x: nextX,\n        y: nextY,\n        data,\n        reset\n      } = yield fn({\n        x,\n        y,\n        initialPlacement: placement,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData,\n        rects,\n        platform,\n        elements: {\n          reference,\n          floating\n        }\n      });\n      x = nextX != null ? nextX : x;\n      y = nextY != null ? nextY : y;\n      middlewareData = {\n        ...middlewareData,\n        [name]: {\n          ...middlewareData[name],\n          ...data\n        }\n      };\n      if (reset && resetCount <= 50) {\n        resetCount++;\n        if (typeof reset === 'object') {\n          if (reset.placement) {\n            statefulPlacement = reset.placement;\n          }\n          if (reset.rects) {\n            rects = reset.rects === true ? yield platform.getElementRects({\n              reference,\n              floating,\n              strategy\n            }) : reset.rects;\n          }\n          ({\n            x,\n            y\n          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n        }\n        i = -1;\n        continue;\n      }\n    }\n    return {\n      x,\n      y,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData\n    };\n  });\n  return function computePosition(_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nfunction detectOverflow(_x4, _x5) {\n  return _detectOverflow.apply(this, arguments);\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction _detectOverflow() {\n  _detectOverflow = _asyncToGenerator(function* (state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      x,\n      y,\n      platform,\n      rects,\n      elements,\n      strategy\n    } = state;\n    const {\n      boundary = 'clippingAncestors',\n      rootBoundary = 'viewport',\n      elementContext = 'floating',\n      altBoundary = false,\n      padding = 0\n    } = evaluate(options, state);\n    const paddingObject = getPaddingObject(padding);\n    const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(yield platform.getClippingRect({\n      element: ((_await$platform$isEle = yield platform.isElement == null ? void 0 : platform.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n      boundary,\n      rootBoundary,\n      strategy\n    }));\n    const rect = elementContext === 'floating' ? {\n      ...rects.floating,\n      x,\n      y\n    } : rects.reference;\n    const offsetParent = yield platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);\n    const offsetScale = (yield platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? (yield platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    };\n    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n      rect,\n      offsetParent,\n      strategy\n    }) : rect);\n    return {\n      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n  });\n  return _detectOverflow.apply(this, arguments);\n}\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  fn(state) {\n    return _asyncToGenerator(function* () {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      // Since `element` is required, we don't Partial<> the type.\n      const {\n        element,\n        padding = 0\n      } = evaluate(options, state) || {};\n      if (element == null) {\n        return {};\n      }\n      const paddingObject = getPaddingObject(padding);\n      const coords = {\n        x,\n        y\n      };\n      const axis = getAlignmentAxis(placement);\n      const length = getAxisLength(axis);\n      const arrowDimensions = yield platform.getDimensions(element);\n      const isYAxis = axis === 'y';\n      const minProp = isYAxis ? 'top' : 'left';\n      const maxProp = isYAxis ? 'bottom' : 'right';\n      const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n      const startDiff = coords[axis] - rects.reference[axis];\n      const arrowOffsetParent = yield platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element);\n      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n      // DOM platform can return `window` as the `offsetParent`.\n      if (!clientSize || !(yield platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n        clientSize = elements.floating[clientProp] || rects.floating[length];\n      }\n      const centerToReference = endDiff / 2 - startDiff / 2;\n\n      // If the padding is large enough that it causes the arrow to no longer be\n      // centered, modify the padding so that it is centered.\n      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n      const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n      // Make sure the arrow doesn't overflow the floating element if the center\n      // point is outside the floating element's bounds.\n      const min$1 = minPadding;\n      const max = clientSize - arrowDimensions[length] - maxPadding;\n      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n      const offset = clamp(min$1, center, max);\n\n      // If the reference is small enough that the arrow's padding causes it to\n      // to point to nothing for an aligned placement, adjust the offset of the\n      // floating element itself. This stops `shift()` from taking action, but can\n      // be worked around by calling it again after the `arrow()` if desired.\n      const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n      const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max - center : 0;\n      return {\n        [axis]: coords[axis] - alignmentOffset,\n        data: {\n          [axis]: offset,\n          centerOffset: center - offset + alignmentOffset\n        }\n      };\n    })();\n  }\n});\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    fn(state) {\n      return _asyncToGenerator(function* () {\n        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n        const {\n          rects,\n          middlewareData,\n          placement,\n          platform,\n          elements\n        } = state;\n        const {\n          crossAxis = false,\n          alignment,\n          allowedPlacements = placements,\n          autoAlignment = true,\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n        const currentPlacement = placements$1[currentIndex];\n        if (currentPlacement == null) {\n          return {};\n        }\n        const alignmentSides = getAlignmentSides(currentPlacement, rects, yield platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n\n        // Make `computeCoords` start from the right place.\n        if (placement !== currentPlacement) {\n          return {\n            reset: {\n              placement: placements$1[0]\n            }\n          };\n        }\n        const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n        const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n          placement: currentPlacement,\n          overflows: currentOverflows\n        }];\n        const nextPlacement = placements$1[currentIndex + 1];\n\n        // There are more placements to check.\n        if (nextPlacement) {\n          return {\n            data: {\n              index: currentIndex + 1,\n              overflows: allOverflows\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n        const placementsSortedByMostSpace = allOverflows.map(d => {\n          const alignment = getAlignment(d.placement);\n          return [d.placement, alignment && crossAxis ?\n          // Check along the mainAxis and main crossAxis side.\n          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n          // Check only the mainAxis.\n          d.overflows[0], d.overflows];\n        }).sort((a, b) => a[1] - b[1]);\n        const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n        // Aligned placements should not check their opposite crossAxis\n        // side.\n        getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n        const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n        if (resetPlacement !== placement) {\n          return {\n            data: {\n              index: currentIndex + 1,\n              overflows: allOverflows\n            },\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n        return {};\n      })();\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    fn(state) {\n      return _asyncToGenerator(function* () {\n        var _middlewareData$flip;\n        const {\n          placement,\n          middlewareData,\n          rects,\n          initialPlacement,\n          platform,\n          elements\n        } = state;\n        const {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = 'bestFit',\n          fallbackAxisSideDirection = 'none',\n          flipAlignment = true,\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        const side = getSide(placement);\n        const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n        const rtl = yield platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n        if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n        }\n        const placements = [initialPlacement, ...fallbackPlacements];\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const overflows = [];\n        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n        if (checkMainAxis) {\n          overflows.push(overflow[side]);\n        }\n        if (checkCrossAxis) {\n          const sides = getAlignmentSides(placement, rects, rtl);\n          overflows.push(overflow[sides[0]], overflow[sides[1]]);\n        }\n        overflowsData = [...overflowsData, {\n          placement,\n          overflows\n        }];\n\n        // One or more sides is overflowing.\n        if (!overflows.every(side => side <= 0)) {\n          var _middlewareData$flip2, _overflowsData$filter;\n          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n          const nextPlacement = placements[nextIndex];\n          if (nextPlacement) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n\n          // First, find the candidates that fit on the mainAxis side of overflow,\n          // then find the placement that fits the best on the main crossAxis side.\n          let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n          // Otherwise fallback.\n          if (!resetPlacement) {\n            switch (fallbackStrategy) {\n              case 'bestFit':\n                {\n                  var _overflowsData$map$so;\n                  const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                  if (placement) {\n                    resetPlacement = placement;\n                  }\n                  break;\n                }\n              case 'initialPlacement':\n                resetPlacement = initialPlacement;\n                break;\n            }\n          }\n          if (placement !== resetPlacement) {\n            return {\n              reset: {\n                placement: resetPlacement\n              }\n            };\n          }\n        }\n        return {};\n      })();\n    }\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    fn(state) {\n      return _asyncToGenerator(function* () {\n        const {\n          rects\n        } = state;\n        const {\n          strategy = 'referenceHidden',\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        switch (strategy) {\n          case 'referenceHidden':\n            {\n              const overflow = yield detectOverflow(state, {\n                ...detectOverflowOptions,\n                elementContext: 'reference'\n              });\n              const offsets = getSideOffsets(overflow, rects.reference);\n              return {\n                data: {\n                  referenceHiddenOffsets: offsets,\n                  referenceHidden: isAnySideFullyClipped(offsets)\n                }\n              };\n            }\n          case 'escaped':\n            {\n              const overflow = yield detectOverflow(state, {\n                ...detectOverflowOptions,\n                altBoundary: true\n              });\n              const offsets = getSideOffsets(overflow, rects.floating);\n              return {\n                data: {\n                  escapedOffsets: offsets,\n                  escaped: isAnySideFullyClipped(offsets)\n                }\n              };\n            }\n          default:\n            {\n              return {};\n            }\n        }\n      })();\n    }\n  };\n};\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    fn(state) {\n      return _asyncToGenerator(function* () {\n        const {\n          placement,\n          elements,\n          rects,\n          platform,\n          strategy\n        } = state;\n        // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n        // ClientRect's bounds, despite the event listener being triggered. A\n        // padding of 2 seems to handle this issue.\n        const {\n          padding = 2,\n          x,\n          y\n        } = evaluate(options, state);\n        const nativeClientRects = Array.from((yield platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n        const clientRects = getRectsByLine(nativeClientRects);\n        const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n        const paddingObject = getPaddingObject(padding);\n        function getBoundingClientRect() {\n          // There are two rects and they are disjoined.\n          if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n            // Find the first rect in which the point is fully inside.\n            return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n          }\n\n          // There are 2 or more connected rects.\n          if (clientRects.length >= 2) {\n            if (getSideAxis(placement) === 'y') {\n              const firstRect = clientRects[0];\n              const lastRect = clientRects[clientRects.length - 1];\n              const isTop = getSide(placement) === 'top';\n              const top = firstRect.top;\n              const bottom = lastRect.bottom;\n              const left = isTop ? firstRect.left : lastRect.left;\n              const right = isTop ? firstRect.right : lastRect.right;\n              const width = right - left;\n              const height = bottom - top;\n              return {\n                top,\n                bottom,\n                left,\n                right,\n                width,\n                height,\n                x: left,\n                y: top\n              };\n            }\n            const isLeftSide = getSide(placement) === 'left';\n            const maxRight = max(...clientRects.map(rect => rect.right));\n            const minLeft = min(...clientRects.map(rect => rect.left));\n            const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n            const top = measureRects[0].top;\n            const bottom = measureRects[measureRects.length - 1].bottom;\n            const left = minLeft;\n            const right = maxRight;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          return fallback;\n        }\n        const resetRects = yield platform.getElementRects({\n          reference: {\n            getBoundingClientRect\n          },\n          floating: elements.floating,\n          strategy\n        });\n        if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n          return {\n            reset: {\n              rects: resetRects\n            }\n          };\n        }\n        return {};\n      })();\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nfunction convertValueToCoords(_x6, _x7) {\n  return _convertValueToCoords.apply(this, arguments);\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nfunction _convertValueToCoords() {\n  _convertValueToCoords = _asyncToGenerator(function* (state, options) {\n    const {\n      placement,\n      platform,\n      elements\n    } = state;\n    const rtl = yield platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n    const side = getSide(placement);\n    const alignment = getAlignment(placement);\n    const isVertical = getSideAxis(placement) === 'y';\n    const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = evaluate(options, state);\n\n    // eslint-disable-next-line prefer-const\n    let {\n      mainAxis,\n      crossAxis,\n      alignmentAxis\n    } = typeof rawValue === 'number' ? {\n      mainAxis: rawValue,\n      crossAxis: 0,\n      alignmentAxis: null\n    } : {\n      mainAxis: 0,\n      crossAxis: 0,\n      alignmentAxis: null,\n      ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === 'number') {\n      crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n      x: crossAxis * crossAxisMulti,\n      y: mainAxis * mainAxisMulti\n    } : {\n      x: mainAxis * mainAxisMulti,\n      y: crossAxis * crossAxisMulti\n    };\n  });\n  return _convertValueToCoords.apply(this, arguments);\n}\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    fn(state) {\n      return _asyncToGenerator(function* () {\n        const {\n          x,\n          y\n        } = state;\n        const diffCoords = yield convertValueToCoords(state, options);\n        return {\n          x: x + diffCoords.x,\n          y: y + diffCoords.y,\n          data: diffCoords\n        };\n      })();\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    fn(state) {\n      return _asyncToGenerator(function* () {\n        const {\n          x,\n          y,\n          placement\n        } = state;\n        const {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: _ref => {\n              let {\n                x,\n                y\n              } = _ref;\n              return {\n                x,\n                y\n              };\n            }\n          },\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        const coords = {\n          x,\n          y\n        };\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const crossAxis = getSideAxis(getSide(placement));\n        const mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        let crossAxisCoord = coords[crossAxis];\n        if (checkMainAxis) {\n          const minSide = mainAxis === 'y' ? 'top' : 'left';\n          const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n          const min = mainAxisCoord + overflow[minSide];\n          const max = mainAxisCoord - overflow[maxSide];\n          mainAxisCoord = clamp(min, mainAxisCoord, max);\n        }\n        if (checkCrossAxis) {\n          const minSide = crossAxis === 'y' ? 'top' : 'left';\n          const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n          const min = crossAxisCoord + overflow[minSide];\n          const max = crossAxisCoord - overflow[maxSide];\n          crossAxisCoord = clamp(min, crossAxisCoord, max);\n        }\n        const limitedCoords = limiter.fn({\n          ...state,\n          [mainAxis]: mainAxisCoord,\n          [crossAxis]: crossAxisCoord\n        });\n        return {\n          ...limitedCoords,\n          data: {\n            x: limitedCoords.x - x,\n            y: limitedCoords.y - y\n          }\n        };\n      })();\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    fn(state) {\n      return _asyncToGenerator(function* () {\n        const {\n          placement,\n          rects,\n          platform,\n          elements\n        } = state;\n        const {\n          apply = () => {},\n          ...detectOverflowOptions\n        } = evaluate(options, state);\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const side = getSide(placement);\n        const alignment = getAlignment(placement);\n        const isYAxis = getSideAxis(placement) === 'y';\n        const {\n          width,\n          height\n        } = rects.floating;\n        let heightSide;\n        let widthSide;\n        if (side === 'top' || side === 'bottom') {\n          heightSide = side;\n          widthSide = alignment === ((yield platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? 'start' : 'end') ? 'left' : 'right';\n        } else {\n          widthSide = side;\n          heightSide = alignment === 'end' ? 'top' : 'bottom';\n        }\n        const overflowAvailableHeight = height - overflow[heightSide];\n        const overflowAvailableWidth = width - overflow[widthSide];\n        const noShift = !state.middlewareData.shift;\n        let availableHeight = overflowAvailableHeight;\n        let availableWidth = overflowAvailableWidth;\n        if (isYAxis) {\n          const maximumClippingWidth = width - overflow.left - overflow.right;\n          availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n        } else {\n          const maximumClippingHeight = height - overflow.top - overflow.bottom;\n          availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n        }\n        if (noShift && !alignment) {\n          const xMin = max(overflow.left, 0);\n          const xMax = max(overflow.right, 0);\n          const yMin = max(overflow.top, 0);\n          const yMax = max(overflow.bottom, 0);\n          if (isYAxis) {\n            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n          } else {\n            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n          }\n        }\n        yield apply({\n          ...state,\n          availableWidth,\n          availableHeight\n        });\n        const nextDimensions = yield platform.getDimensions(elements.floating);\n        if (width !== nextDimensions.width || height !== nextDimensions.height) {\n          return {\n            reset: {\n              rects: true\n            }\n          };\n        }\n        return {};\n      })();\n    }\n  };\n};\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };","map":{"version":3,"names":["getSideAxis","getAlignmentAxis","getAxisLength","getSide","getAlignment","evaluate","getPaddingObject","rectToClientRect","min","clamp","placements","getAlignmentSides","getOppositeAlignmentPlacement","getOppositePlacement","getExpandedPlacements","getOppositeAxisPlacements","sides","max","getOppositeAxis","computeCoordsFromPlacement","_ref","placement","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","side","isVertical","commonX","x","width","commonY","y","height","commonAlign","coords","computePosition","_ref2","_asyncToGenerator","config","strategy","middleware","platform","validMiddleware","filter","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","length","name","fn","nextX","nextY","data","reset","initialPlacement","elements","_x","_x2","_x3","apply","arguments","detectOverflow","_x4","_x5","_detectOverflow","state","options","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","padding","paddingObject","altContext","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","rect","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","top","bottom","left","right","arrow","axis","arrowDimensions","getDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","centerOffset","getPlacementList","alignment","autoAlignment","allowedPlacements","allowedPlacementsSortedByAlignment","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_placementsThatFitOnE","crossAxis","detectOverflowOptions","placements$1","undefined","overflow","currentIndex","index","currentPlacement","alignmentSides","currentOverflows","allOverflows","overflows","nextPlacement","placementsSortedByMostSpace","map","d","slice","reduce","acc","v","sort","a","b","placementsThatFitOnEachSide","every","resetPlacement","flip","_middlewareData$flip","mainAxis","checkMainAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","isBasePlacement","push","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","_overflowsData$map$so","getSideOffsets","isAnySideFullyClipped","some","hide","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","getBoundingRect","minX","minY","maxX","maxY","getRectsByLine","sortedRects","groups","prevRect","inline","nativeClientRects","Array","from","getClientRects","clientRects","fallback","getBoundingClientRect","find","firstRect","lastRect","isTop","isLeftSide","maxRight","minLeft","measureRects","resetRects","convertValueToCoords","_x6","_x7","_convertValueToCoords","mainAxisMulti","includes","crossAxisMulti","rawValue","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse","_middlewareData$offse2","isOriginSide","size","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions"],"sources":["C:/Repository/Jupiter/juno-app/node_modules/@floating-ui/core/dist/floating-ui.core.mjs"],"sourcesContent":["import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset + alignmentOffset\n      }\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}