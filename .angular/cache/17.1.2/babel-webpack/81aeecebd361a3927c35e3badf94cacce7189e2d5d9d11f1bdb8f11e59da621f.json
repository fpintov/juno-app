{"ast":null,"code":"import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  /**\n  Create an input rule. The rule applies when the user typed\n  something and the text directly in front of the cursor matches\n  `match`, which should end with `$`.\n  \n  The `handler` can be a string, in which case the matched text, or\n  the first matched group in the regexp, is replaced by that\n  string.\n  \n  Or a it can be a function, which will be called with the match\n  array produced by\n  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  as well as the start and end of the matched range, and which can\n  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n  rule's effect, or null to indicate the input was not handled.\n  */\n  constructor(\n  /**\n  @internal\n  */\n  match, handler) {\n    this.match = match;\n    this.match = match;\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n  }\n}\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    let insert = string;\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      let cutOff = start - end;\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n    return state.tr.insertText(insert, start, end);\n  };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({\n  rules\n}) {\n  let plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this);\n        if (stored) return stored;\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            let {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false;\n  let state = view.state,\n    $from = state.doc.resolve(from);\n  if ($from.parent.type.spec.code) return false;\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore);\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n    if (!tr) continue;\n    view.dispatch(tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    }));\n    return true;\n  }\n  return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n  let plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i],\n      undoable;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr,\n          toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j--) tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n        dispatch(tr);\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    let tr = state.tr.delete(start, end);\n    let $start = tr.doc.resolve(start),\n      range = $start.blockRange(),\n      wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) return null;\n    tr.wrap(range, wrapping);\n    let before = tr.doc.resolve(start - 1).nodeBefore;\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);\n    return tr;\n  });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start);\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":{"version":3,"names":["Plugin","findWrapping","canJoin","InputRule","constructor","match","handler","stringHandler","string","state","start","end","insert","offset","lastIndexOf","slice","length","cutOff","tr","insertText","MAX_MATCH","inputRules","rules","plugin","init","apply","prev","stored","getMeta","selectionSet","docChanged","props","handleTextInput","view","from","to","text","run","handleDOMEvents","compositionend","setTimeout","$cursor","selection","pos","isInputRules","composing","$from","doc","resolve","parent","type","spec","code","textBefore","textBetween","Math","max","parentOffset","i","exec","dispatch","setMeta","transform","undoInputRule","plugins","undoable","getState","toUndo","j","steps","step","invert","docs","marks","replaceWith","schema","delete","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","wrappingInputRule","regexp","nodeType","getAttrs","joinPredicate","attrs","Function","$start","range","blockRange","wrapping","wrap","before","nodeBefore","join","textblockTypeInputRule","node","canReplaceWith","index","indexAfter","setBlockType"],"sources":["C:/Repository/Jupiter/juno-app/node_modules/prosemirror-inputrules/dist/index.js"],"sourcesContent":["import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule's effect, or null to indicate the input was not handled.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    match, handler) {\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n    }\n}\nfunction stringHandler(string) {\n    return function (state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({ rules }) {\n    let plugin = new Plugin({\n        state: {\n            init() { return null; },\n            apply(tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored)\n                    return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        let { $cursor } = view.state.selection;\n                        if ($cursor)\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing)\n        return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    if ($from.parent.type.spec.code)\n        return false;\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n    for (let i = 0; i < rules.length; i++) {\n        let match = rules[i].match.exec(textBefore);\n        let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n        if (!tr)\n            continue;\n        view.dispatch(tr.setMeta(plugin, { transform: tr, from, to, text }));\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n    let plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i++) {\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n            (!joinPredicate || joinPredicate(match, before)))\n            tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\n            return null;\n        return state.tr\n            .delete(start, end)\n            .setBlockType(start, start, nodeType, attrs);\n    });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}